---
title: "Langton"
output: word_document
date: "2025-01-21"
---

# Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(data.table)
library(here)
```

```{r getData}
#| eval: FALSE
# The originally generated data consist of nrow(ants) ticks on a 
#  grid that is 161 x 161. The patches data are sorted by (x,y), from
#  upper left to lower right, working across the rows. The ticks are 0-based
#  and in the original the grid is [-80,80] x [-80,80], with the upper left
#  corner being (-80,80).
#
# These were generated by NetLogo, and then the files were edited to remove
#  some unwanted characters.
#
# All patches not listed in Patches.txt are "white"; only "black" patches
#  are listed. 

fread(file = here("Data/Ants.txt"),
      col.names = c("Time", "X", "Y")) ->
  ants_df                                   # 12005 ticks
save(ants_df,
     file = here("Data/Ants.RData"))

fread(file = here("Data/Patches.txt"),
      col.names = c("Time", "X", "Y", "Col")) ->
  patches_df                                # 5,404,453 colored patches out of
                                            #  311,181,605 total patches.
patches_df[, -4] ->                         # Column 4 has only 1 unique value.
  patches_df
save(patches_df,
     file = here("Data/Patches.RData"))

```

```{r loadData}
load(here("Data/Patches.RData"))
load(here("Data/Ants.RData"))
```

```{r createDF}
# Make a data frame with tick, ant_x, ant_y, and the grid of pcolor. This
#  will be quite large, and so will slow things down unless (a) you work
#  in package::data.table format, (b) you use multiple cores (e.g., parallel
#  processing) and/or (c) are clever about management. Also, note that
#  a lot of the field was not used:
range(patches_df$X)                         # [1] -33  23
range(patches_df$Y)                         # [1] -29  57
# Hence, one does NOT need a gridsize of 161 x 161, but rather a grid of
#  [-35,25] x [-30,60] (where I put in some buffer so we can draw nicer
#  looking graphs). This is 61 * 91, which is only about a fifth of the
#  original grid. Still, after 12005 ticks, this will be almost 67 million
#  rows in long data format.

```

```{r plots}
plot(ants_df$X,
     ylim = c(-35,60),
     type = 'l',
     xlab = "Time",
     ylab = "X")
lines(ants_df$Y,
     col = "blue")

```

# Changepoints

First, find the classical changepoints with mean and variance
```{r}
library(changepoint)                        # Find classical changepoints

cpt.mean(ants_df$Y)                         # Find changepoints in means
cpt.mean(ants_df$X)

plot(ants_df$X,                             # Plot as above
     ylim = c(-35,60),
     type = 'l',
     xlab = "Time",
     ylab = "X")
lines(ants_df$Y,
     col = "blue")
abline(v = cpt.mean(ants_df$X,
                    method = "SegNeigh",
                    penalty = "AIC")@cpts,        # Draw vertical lines at cpts
       col = "black")
abline(v = cpt.mean(ants_df$Y,
                    method = "SegNeigh",
                    penalty = "AIC")@cpts, 
       col = "blue")

```

Wolpert (199x) - "The "No Free Lunch" Theorem"

How do we know the change is "real"? Each method finds different changepoints.

HW 1: Do this with cpt.vars() in place of cpt.mean()

How can we anticipate the change without false positives and false negatives?

Now, let's find the changepoints via windowed entropy or something like that.

Windowed entropy is promising, but there are others. ML/AI? Etc. Recall:

$ S = -k \sum_i p_i log p_i$

Window size: Pick one and see what happens.

To find the probabilities, because the ant only works with integers, we can use the table() function. (One approach to continuous values is to define bins, like in a histogram.)

```{r}
table(ants_df$X[1:2000]) -> x2000      # Don't look everywhere yet
table(ants_df$Y[1:2000]) -> y2000      # Don't look everywhere yet
x2000
y2000

table(ants_df$X[1:2000],                # Joint, mutual counts
      ants_df$Y[1:2000]) -> xy2000
xy2000

xy2000 / sum(xy2000) ->                 # Probabilities
  pxy2000

pxy2000
```

# Early Warning Signal

Remember: Windowed entropy becomes a maximum. (When windowed entropy increases, we get an EWS.)

HW2: Calculate windowed entropies for the ant's X and Y. Try different window sizes. Whatever.

Thinking: From your playing around in HW2, how can we remove false positives?
a) Window size adjustments
b) Additional data streams

window sizing and finding changepoints.

```{r}
20 -> win_sz

nrow(ants_df) - win_sz -> time_steps

ent_calc <- function(x, win_sz, time_steps) {
vector(mode = "numeric",
       length = time_steps) ->
  entropy_x

for(index in 1:time_steps) {
  # Probabilities "offline" - use the entire sequence
  # Probabilities "online" - use only the data up to the window
  
  table(x[1:(index+win_sz)]) /
    (index+win_sz) ->
    prob_online
  
  # Need to find a more general way to do this now.
  -sum(prob_online[as.character(x[index:(index + win_sz)])] *
    log(prob_online[as.character(x[index:(index + win_sz)])])) ->
    entropy_x[index]
}
  return(entropy_x)
}
```
Check by hand:

```{r}
table(ants_df$X[1:9]) /
    9 ->
    prob_online

(5/9) * log(5/9) + (5/9) * log(5/9) + (2/9) * log(2/9) + (2/9) * log(2/9) +
  (5/9) * log(5/9) + (5/9) * log(5/9) + (2/9) * log(2/9) + (2/9) * log(2/9) + 
  (5/9) * log(5/9)

5 * ((5/9) * log(5/9)) + 2 * ((2/9) * log(2/9) + 2 * ((2/9 * log(2/9))))

```

Check worked, so change 200 to the nrow(ants_d)
```{r}
plot(entropy_x, type = 'l')
```
```{r}
ent_calc(ants_df$X, 8, time_steps) ->
  ent8

ent_calc(ants_df$X, 16, time_steps) ->
  ent16

```


HW 3:
- How to access a vector (like prob_online) by name, not index












